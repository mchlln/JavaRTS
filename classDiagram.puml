@startuml

package "Model" <<Frame>> {

package "Building"{
    interface Building {
        + getName() : String
        + getSize() : Size
        + getCost() : HashMap<Resource, Integer>
        + getId() : UUID
        + getConstructionTime() : ??
        + getType() : BuildingType
        + getPosition() : Position
        + getFunctions() : ArrayList<BuildingFunctions>
        + addFunction(ArrayList<BuildingFunction>)
        + getWorkers() : List<People>
        + getMaxWorkers() : Integer
        + getNumberWorkers() : Integer
        + addWorker(People) : boolean
        + removeWorker(People) : void
        + getInhabitants() : List<People>
        + getMaxInhabitants() : Integer
        + getNumberInhabitants() : Integer
        + addInhabitant(People) : boolean
        + removeInhabitant(People) : void
        + getDailyProduction() : Map<ResourceType, Integer> 
        + getDailyConsumption() : Map<ResourceType, Integer>
        + handle() : HashMap<ResourceType,Integer>
    }

    class BasicBuilding implements Building{}

    class ConsumptionBuilding extends BuildingDecorator{
        - building : Building
        - dailyConsumption : Map<ResourceType, Integer>
    }
    class ProductionBuilding extends BuildingDecorator{
        - building : Building
        - dailyProduction : Map<ResourceType, Integer>
    }
    class LivingBuilding extends BuildingDecorator{
        - inhabitants : List<People>
        
    }
    class WorkingBuilding extends BuildingDecorator{
        - workers : List<People>
    }

    abstract class BuildingDecorator implements Building{
        - decoratedBuilding : Building
    }
    note left of BuildingDecorator
        Design Pattern Decorator
    end note

    class BuildingManager <<(S,#FF7700)Singleton>> {
        - buildings : Set<Building>
        + addBuilding(Building) : void
        + removeBuilding(Building) : void
        + getInhabitants(Building) : void
    }

    class BuildingBuilder{
        + build(BuildingType, Position) : Building
    }

    enum BuildingFunction{
        WORKING
        LIVING
        PRODUCING
        CONSUMING
    }

    enum BuildingType{
        WOODENCABIN
        HOUSE
        APPARTMENTBUILDING
        FARM
        QUARRY
        LUMBERMILL
        CEMENTPLANT
        STEELMILL
        TOOLFACTORY
    }
}
package "State"{
    interface State{
        + loop() : void
    }

    abstract class AbstractState implements State{
        - currentState : States
        + creation() : void
        + running() : void
        + broken() : void
        + boost() : void
        + blocked() : void
        + getStates() : States
    }

    class Automata{
        - currentState : States
        + setCurrentState(AbstractState currentState) : void
        + GetCurrentState() : AbstractState
        + getCurrentStateName() : States
    }
    class BlockedState extends AbstractState{
        - automata : Automata
        + running() : void
    }
    class BoostState extends AbstractState{
        - automata : Automata
        + running() : void
        + broken() : void
        + blocked() : void
    }
    class BrokenState extends AbstractState{
        - automata : Automata
        + running() : void
    }
    class ConstructionState extends AbstractState{
        - automata : Automata
        + running() : void
    }
    class RunningState extends AbstractState{
        - automata : Automata
        + boost() : void
        + broken() : void
        + blocked() : void
    }

    enum States{
        CONSTRUCTION
        RUNNING
        BROKEN
        BOOSTED
        BLOCKED
    }
}

    class People{
        - id : UUID
        - House : Building
        - Job : Building
        - FoodCost : Integer
        + getHouse() : Building
        + getJobPlace() : Building
        + getId() : Building
        + affectHouse(Building) : void
        + affectJobPlace(Building) : void
    }
    class Map <<(S,#FF7700)Singleton>>{
        - size : Size
        - tiles : MapTileStatus[][]
        + getTileStatus(Position) : MapTilestatus
        + isAreaFree(Position, Size) : Boolean
        + Construct(Position, Size)
        + Destruct(Position, Size)
    }

    enum MapTileStatus {
        FREE
        OCCUPIED
    }
    class GameManager <<(S,#FF7700)Singleton>> implements Subject{
        - instance : GameManager
        - worldInhabitants : List<People>
        - map : Map
        - resources : ResourceManager
        - buildings : BuildingManager
        - observers : Set<Runnable>
        - currentException : Exception
        - timeline : Timeline
        - b : BuildingBuilder
        + loop() : void
        + getInstance() : GameManager
        + addBuilding(BuildingType, Position) : void
        + removeBuilding(Building) : void
        + createInhabitantInto(Building) : void
        + deleteInhabitantFrom(Building) : void
        + assignWorkerTo(Building) : void
        + findUnemployed() : People
        + deleteWorkerFrom(Building) : void
        + getBuildings() : Set<Building>
    }
    note left of GameManager
        Design Pattern Singleton
        Design Pattern Composite
        Design Pattern Observer (Subject)
    end note

    class Size{
        - width : Integer
        - height : Integer
        + getSize() : [Integer, Integer]
        + getWidth() : Integer
        + getHeight() : Integer
    }

    interface Subject{
        + addObserver(Runnable) : void
        + addErrorListener(Runnable) : void
        + removeObserver(Runnable) : void
        + notifyObservers() : void
        + notifyErrorListener(Exception) : void
    }
    class Position{
        - x : Integer
        - y : Integer
        + getX() : Integer
        + getY() : Integer
    }


package "Resource"{
    interface Resource {
        + getType() : RessourceType
        + getQuantity() : Integer
        + addResources(quantity : Integer)
        + removeResources(quantity : Integer)

    }
    abstract class ResourceDecorator implements Resource{
        - Type : RessourceType
        - Quantity : Integer
        + handle() : HashMap<ResourceType,Integer>
    }
    note right of ResourceDecorator
        Design Pattern Decorator
    end note

    class Food extends ResourceDecorator{

    }
    class Wood extends ResourceDecorator{

    }
    class Stone extends ResourceDecorator{

    }
    class Coal extends ResourceDecorator{

    }
    class Iron extends ResourceDecorator{

    }
    class Steel extends ResourceDecorator{

    }
    class Cement extends ResourceDecorator{

    }
    class Lumber extends ResourceDecorator{

    }
    class Tools extends ResourceDecorator{

    }
    enum ResourceType{
        FOOD
        WOOD
        STONE
        COAL
        IRON
        STEEL
        CEMENT
        LUMBER
        TOOLS
    }

    class ResourceManager <<(S,#FF7700)Singleton>>{
        - resources : HashMap<ResourceType,ResourceDecorator>
        - instance : ResourceManager
        + addResources(ResourceType type, Integer quantity)
        + removeResources(ResourceType type, Integer quantity)
        + getInstance() : ResourceManager
        + areAvailable(HashMap<ResourceType, Integer>) : boolean
        + getResources() : HashMap<ResourceType, Integer>
    }
    note left of ResourceManager
        Design Pattern Singleton
    end note
}



}

package "Exception" <<Frame>>{
    exception NotEnoughSpace{}
    exception TooManyInhabitants{}
    exception NotEnoughResources{}
    exception MapTileStateException{}
    exception NotEnoughInhabitants{}
    exception NotEnoughWorkers{}
    exception TooManyWorkers{}
    exception WrongBuildingType{}
    exception WrongResourceType{}
    exception WrongState{}
}

package "View" {
    interface Observer{
        + update()
    }
    note left of Observer
        Design Pattern Observer
    end note
    class View implements Observer{}
}

package "Controller" {
    class Controller{
        - model GameManager
        - view MainView
        - bagOfCommands : BagOfCommands
        - selectedBuilding : BuildingType
        + changeSelectedBuilding(BuildingType)
    }
    interface Command{
        + execute(GameManager, Controller)
    }
    note left of Command
        Design Pattern Command
    end note

    class AddBuildingCommand implements Command{
        - position : Position
    }
    class RemoveBuildingCommand implements Command{
        - building : Building
    }
    class AddInhabitantInto implements Command{
         - building : Building
    }
    class RemoveInhabitantFrom implements Command{
         - building : Building
    }
    class AddWorkerInto implements Command{
         - building : Building
    }
    class RemoveWorkerFrom implements Command{
         - building : Building
    }
    class SetSelectedBuilding implements Command{
         - type : BuildingType
    }
    class SetSelectedBuildingInfo implements Command{
         - type : BuildingType
    }
    class BlockBuildingCommand implements Command{
        - type : BuildingType
    }
    class BoostBuildingCommand implements Command{
        - type : BuildingType
    }
    class RepairBuildingCommand implements Command{
        - type : BuildingType
    }
    class RunBuildingCommand implements Command{
        - type : BuildingType
    }

    class BagOfCommands  <<(S,#FF7700)Singleton>>{
        - instance : BagOfCommands
        - commands : ConcurrentLinkedQueue<Command>
        - model : GameManager
        - controller : Controller
        - is_running : boolean
        - processCommands() : void
        + getInstance() : BagOfCommands
        + executeFirst() : void
        + executeAll() : void
        + addCommand(Command) : void
        + setModel(GameManager) : void
        + setController(Controller) : void
    }
    note bottom of BagOfCommands
        Design Pattern Singleton
    end note
}


    ResourceType -->ResourceDecorator::Type
    BuildingType -->BuildingDecorator::Type
    Map --> GameManager::Map
    Size --> Map::size
    People --> GameManager::worldInhabitants
    People --> LivingBuilding::inhabitants
    People --> WorkingBuilding::workers
    BuildingDecorator --> GameManager::buildings
    ResourceManager --> GameManager::resources
    MapTileStatus --> Map::tiles
    ResourceDecorator --> ResourceManager::resources
    BuildingFunction --> BuildingDecorator::functions
    BagOfCommands --> Controller::commands
    GameManager --> Controller::model
    Position --> Map::getTileStatus
    Command --> BagOfCommands::commands
@enduml
